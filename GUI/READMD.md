Here's the classification of each design pattern based on its type:

| **File Name**  | **Pattern Name**      | **Type**       |
| -------------- | --------------------- | -------------- |
| `adapter.py`   | **Adapter Pattern**   | **Structural** |
| `factory.py`   | **Factory Pattern**   | **Creational** |
| `observer.py`  | **Observer Pattern**  | **Behavioral** |
| `singleton.py` | **Singleton Pattern** | **Creational** |
| `proxy.py`     | **Proxy Pattern**     | **Structural** |
| `strategy.py`  | **Strategy Pattern**  | **Behavioral** |
| `iterator.py`  | **Iterator Pattern**  | **Behavioral** |
| `mediator.py`  | **Mediator Pattern**  | **Behavioral** |
| `state.py`     | **State Pattern**     | **Behavioral** |
| `builder.py`   | **Builder Pattern**   | **Creational** |
| `prototype.py` | **Prototype Pattern** | **Creational** |
| `facade.py`    | **Facade Pattern**    | **Structural** |

### **Explanation of Types:**

1. **Creational Patterns** → Focus on object creation.

   - **Factory**: Creates objects dynamically.
   - **Singleton**: Ensures only one instance of a class exists.
   - **Builder**: Creates objects step by step.
   - **Prototype**: Creates new objects by copying existing ones.

2. **Structural Patterns** → Deal with object composition and relationships.

   - **Adapter**: Makes incompatible interfaces work together.
   - **Proxy**: Controls access to another object.
   - **Facade**: Provides a simplified interface to a complex subsystem.

3. **Behavioral Patterns** → Define how objects interact and distribute responsibilities.

   - **Observer**: Implements a publish-subscribe mechanism.
   - **Strategy**: Enables interchangeable behaviors at runtime.
   - **Iterator**: Provides sequential access to elements without exposing underlying structure.
   - **Mediator**: Reduces dependencies between objects by centralizing communication.
   - **State**: Allows an object to alter its behavior when its internal state changes.
